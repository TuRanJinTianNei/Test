% ============================================================================
% 卷积物理意义模拟：低通滤波过程
% ============================================================================
% 目的：通过移动平均滤波器对带噪声信号滤波，展示卷积的"拆解-延迟-叠加"过程
%
% 卷积的物理意义理解：
% 1. 拆解：将输入信号x(n)拆解为无数个冲激分量的叠加
%    x(n) = Σ x(k)·δ(n-k)，其中δ(n-k)是时刻k的单位冲激
%
% 2. 延迟：每个冲激分量x(k)·δ(n-k)经过系统后，产生延迟响应x(k)·h(n-k)
%    这是因为系统的时不变性：如果δ(n)产生h(n)，那么δ(n-k)产生h(n-k)
%    线性性：如果输入是x(k)·δ(n-k)，输出是x(k)·h(n-k)
%
% 3. 叠加：将所有延迟响应叠加，得到最终输出
%    y(n) = Σ x(k)·h(n-k) = x(n) * h(n)  （这就是卷积公式）
%
% 本程序通过可视化展示这个过程，帮助理解卷积的本质
% ============================================================================

clear; clc; close all;

%% 1. 生成时间序列与输入信号
% ============================================================================
% 步骤1：创建输入信号
% ============================================================================
% 时间轴（离散时间点）
n = 0:100;  % 共101个时刻（从0到100）
N = length(n);  % N = 101

% 输入信号：低频信号（正弦波）+ 高频噪声（模拟真实含噪信号）
% 为什么要用带噪声的信号？因为这样可以直观看到滤波器的效果
x_low = 2*sin(0.2*n);  % 低频信号（幅度2，频率0.2rad/点）- 这是我们想保留的信号
x_noise = 0.8*randn(1, N);  % 高频噪声（均值0，方差0.8）- 这是我们想滤除的噪声
x = x_low + x_noise;  % 带噪声的输入信号 = 有用信号 + 噪声

% 理解：x(n)在时刻n的值，可以看作是在时刻n的一个"冲激分量"
% 例如：x(20)可以看作是在n=20时刻，幅度为x(20)的冲激分量


%% 2. 定义系统冲激响应（低通滤波器）
% ============================================================================
% 步骤2：定义系统的冲激响应h(n)
% ============================================================================
% 冲激响应h(n)的定义：当输入是单位冲激δ(n)时，系统的输出就是h(n)
% 
% 我们选用9点移动平均滤波器：
% - 作用：对信号进行平滑，滤除高频噪声
% - 原理：取当前时刻及前后共9个时刻的平均值
% - 效果：高频噪声被平均掉，低频信号保留
%
M = 9;  % 滤波器长度（冲激响应持续9个时刻）
h = ones(1, M) / M;  % 冲激响应：[1/9, 1/9, ..., 1/9]（共9个，每个都是1/9）

% 物理意义理解：
% h(n)表示"单位冲激输入δ(n)"时，系统在各时刻的输出
% 例如：h(0)=1/9表示：如果在n=0时刻输入单位冲激，系统在n=0时刻输出1/9
%      h(1)=1/9表示：如果在n=0时刻输入单位冲激，系统在n=1时刻输出1/9
%      ...依此类推，持续9个时刻
%
% 为什么是1/9？因为这是9点平均，每个点的权重都是1/9，总和为1（归一化）


%% 3. 计算卷积输出（滤波结果）
% ============================================================================
% 步骤3：计算卷积输出（这是最终结果）
% ============================================================================
% 卷积公式：y(n) = Σ x(k)·h(n-k) = x(n) * h(n)
% 
% MATLAB的conv函数会自动完成以下过程：
% 1. 对每个时刻k的输入x(k)，计算延迟响应x(k)·h(n-k)
% 2. 将所有延迟响应叠加，得到y(n)
%
y = conv(x, h, 'same');  % 用'same'保证输出长度与输入一致（取中间有效部分）

% 物理意义：y(n)是输入x的所有冲激分量对应的延迟响应的叠加
% 例如：y(25) = x(20)·h(5) + x(21)·h(4) + x(22)·h(3) + ... + x(25)·h(0) + ...
%      这是所有在时刻25之前（或附近）的输入冲激分量，经过延迟后，在时刻25的响应的叠加


%% 4. 模拟卷积分步过程（展示关键步骤）
% ============================================================================
% 步骤4：详细展示卷积的"拆解-延迟-叠加"过程
% ============================================================================
% 为了帮助理解，我们选取输入信号中的3个关键时刻，展示它们各自的延迟响应
% 这样可以看到：每个输入冲激分量如何产生延迟响应，以及这些响应如何叠加

k_list = [20, 50, 80];  % 选取的输入时刻（τ=20, 50, 80）- 我们重点观察这3个时刻
y_k_list = cell(1, length(k_list));  % 存储每个冲激分量对应的延迟响应

fprintf('\n========== 卷积过程详解 ==========\n');
fprintf('我们将展示3个输入冲激分量如何产生延迟响应：\n\n');

for i = 1:length(k_list)
    k = k_list(i);  % 当前冲激分量的时刻τ=k（例如k=20）
    x_k = x(k+1);   % 该时刻的输入幅度（x是1索引，n是0索引，需+1）
    
    fprintf('时刻 %d 的输入冲激分量：\n', k);
    fprintf('  - 输入值 x(%d) = %.4f\n', k, x_k);
    fprintf('  - 这个值可以看作是在n=%d时刻的一个冲激，幅度为%.4f\n', k, x_k);
    
    % ========================================================================
    % 关键步骤：生成该冲激分量对应的延迟冲激响应
    % ========================================================================
    % 原理：
    % 1. 时不变性：如果δ(n)产生h(n)，那么δ(n-k)产生h(n-k)
    %    也就是说，如果单位冲激延迟k时刻，响应也延迟k时刻
    % 2. 线性性：如果输入是x(k)·δ(n-k)，输出是x(k)·h(n-k)
    %    也就是说，如果冲激幅度是x(k)，响应幅度也按比例缩放
    %
    % 因此：在时刻k的输入冲激x(k)·δ(n-k)，产生的响应是x(k)·h(n-k)
    % 这个响应从时刻k开始，持续M个时刻（因为h的长度是M）
    
    y_k = zeros(1, N + M - 1);  % 初始化响应数组（长度=输入长+冲激响应长-1）
    start_idx = k + 1;  % 延迟k时刻后的起始位置（1索引，因为MATLAB从1开始）
    end_idx = start_idx + M - 1;  % 响应结束位置（h的长度为M，所以需要M个位置）
    
    % 边界检查：确保索引不超出数组范围
    % 检查start_idx是否有效
    if start_idx < 1
        start_idx = 1;
    end
    
    % 检查end_idx是否超出数组范围，并调整h的长度
    if end_idx > length(y_k)
        end_idx = length(y_k);  % 如果超出，截断到数组末尾
    end
    
    % 计算实际可用的索引范围长度
    idx_range_length = end_idx - start_idx + 1;
    
    % 如果起始位置超出数组，使用零向量
    if start_idx > length(y_k) || idx_range_length <= 0
        fprintf('  警告：时刻%d的响应超出数组范围，使用零向量\n', k);
        y_k_list{i} = zeros(1, N);  % 返回零向量
    else
        % 根据实际索引范围调整h的长度
        if idx_range_length < M
            h_used = h(1:idx_range_length);  % 只使用能放入的部分
        else
            h_used = h;  % 使用完整的h
        end
        
        % 确保h_used的长度与索引范围完全匹配
        if length(h_used) ~= idx_range_length
            h_used = h_used(1:min(length(h_used), idx_range_length));
            % 如果h_used太短，用零填充
            if length(h_used) < idx_range_length
                h_used = [h_used, zeros(1, idx_range_length - length(h_used))];
            end
        end
        
        % 最终验证：确保长度完全匹配（用于调试）
        actual_idx_length = end_idx - start_idx + 1;
        if length(h_used) ~= idx_range_length || actual_idx_length ~= idx_range_length
            fprintf('  调试信息：k=%d, start_idx=%d, end_idx=%d\n', k, start_idx, end_idx);
            fprintf('  调试信息：idx_range_length=%d, actual_idx_length=%d, h_used长度=%d\n', ...
                idx_range_length, actual_idx_length, length(h_used));
            % 强制匹配：使用实际索引长度
            idx_range_length = actual_idx_length;
            if length(h_used) > idx_range_length
                h_used = h_used(1:idx_range_length);
            elseif length(h_used) < idx_range_length
                h_used = [h_used, zeros(1, idx_range_length - length(h_used))];
            end
        end
        
        % 填充延迟后的响应：x(k)·h(n-k)
        % 注意：h原本从n=0开始，延迟k时刻后，从n=k开始
        % x_k是标量，h_used是向量，x_k * h_used 是向量，长度等于h_used的长度
        response_vector = x_k * h_used;  % 先计算响应向量
        
        % 最后一次检查：确保response_vector的长度与索引范围匹配
        if length(response_vector) ~= (end_idx - start_idx + 1)
            fprintf('  错误：响应向量长度(%d)与索引范围长度(%d)不匹配！\n', ...
                length(response_vector), end_idx - start_idx + 1);
            fprintf('  调整响应向量长度...\n');
            if length(response_vector) > (end_idx - start_idx + 1)
                response_vector = response_vector(1:(end_idx - start_idx + 1));
            else
                response_vector = [response_vector, zeros(1, (end_idx - start_idx + 1) - length(response_vector))];
            end
        end
        
        % 最终赋值前的最后检查
        left_length = end_idx - start_idx + 1;
        right_length = length(response_vector);
        
        if left_length ~= right_length
            fprintf('\n!!! 错误：长度不匹配 !!!\n');
            fprintf('  左侧索引范围长度: %d (start_idx=%d, end_idx=%d)\n', left_length, start_idx, end_idx);
            fprintf('  右侧向量长度: %d\n', right_length);
            fprintf('  调整右侧向量长度以匹配左侧...\n');
            
            if right_length > left_length
                response_vector = response_vector(1:left_length);
            else
                response_vector = [response_vector, zeros(1, left_length - right_length)];
            end
            fprintf('  调整后右侧向量长度: %d\n', length(response_vector));
        end
        
        % 执行赋值
        y_k(start_idx:end_idx) = response_vector;  % 赋值（此时长度一定匹配）
        
        % 截取与输入等长的部分（便于叠加展示）
        % 因为y_k的长度是N+M-1，我们需要截取中间N个点，与输入对齐
        y_k_list{i} = y_k(ceil(M/2):ceil(M/2)+N-1);
        
        fprintf('  - 产生的延迟响应：从n=%d开始，持续%d个时刻\n', k, M);
        fprintf('  - 响应幅度：x(%d)·h = %.4f × [1/9, 1/9, ..., 1/9]\n', k, x_k);
        fprintf('  - 这个响应会叠加到最终输出的n=%d到n=%d时刻\n\n', k, k+M-1);
    end
end

fprintf('最终输出y(n) = 所有时刻的延迟响应的叠加\n');
fprintf('例如：y(25) = x(20)·h(5) + x(21)·h(4) + x(22)·h(3) + ...\n');
fprintf('===================================\n\n');


%% 5. 可视化所有结果（物理意义标注）
% ============================================================================
% 步骤5：可视化展示卷积的完整过程
% ============================================================================
% 这个图展示了4个关键步骤，帮助理解卷积的物理意义

figure('Name', '卷积物理意义模拟：低通滤波过程', 'Position', [100, 100, 1200, 900]);

% ============================================================================
% 子图1：输入信号（带噪声）
% ============================================================================
% 这个图展示我们要处理的输入信号
% - 蓝色实线：带噪声的输入信号x(n)
% - 红色虚线：原始的低频信号（这是我们想保留的）
% - 可以看到噪声使得信号变得不平滑
subplot(4,1,1);
plot(n, x, 'b', 'LineWidth', 1.2);
hold on;
plot(n, x_low, 'r--', 'LineWidth', 1);  % 叠加原始低频信号（参考）
xlabel('时间n'); ylabel('幅度');
title('1. 输入信号x(n)：低频信号+高频噪声（红色虚线为无噪声原始信号）');
legend('带噪声输入x(n)', '原始低频信号x_{low}(n)', 'Location', 'best');
grid on;
text(80, max(x)-0.5, '理解：x(n)可以拆解为无数个冲激分量的叠加', 'FontSize', 9, 'Color', 'blue');

% ============================================================================
% 子图2：系统冲激响应h(n)
% ============================================================================
% 这个图展示系统的特性：当输入是单位冲激时，输出是什么
% - 黑色竖线：h(n)的值，每个都是1/9
% - 持续9个时刻：说明一个冲激输入会产生9个时刻的响应
% - 这是9点移动平均滤波器：取9个时刻的平均值
subplot(4,1,2);
stem(n(1:M), h, 'k', 'LineWidth', 1.5, 'MarkerSize', 8);  % 冲激响应仅前9个时刻有值
xlabel('时间n'); ylabel('幅度');
title('2. 系统冲激响应h(n)：9点移动平均滤波器（单位冲激δ(n)的输出）');
text(5, 0.12, 'h(n) = [1/9, 1/9, ..., 1/9]（共9点）', 'Color', 'blue', 'FontSize', 10);
text(5, 0.10, '物理意义：如果在n=0输入单位冲激，系统在n=0到n=8时刻都有输出', ...
    'Color', 'red', 'FontSize', 9);
grid on;

% ============================================================================
% 子图3：关键冲激分量的延迟响应（卷积中间步骤）
% ============================================================================
% 这个图展示卷积的"延迟"过程：
% - 我们选取了3个时刻（n=20, 50, 80）的输入冲激分量
% - 每个冲激分量产生一个延迟响应
% - 紫色线：n=20时刻的输入产生的响应（从n=20开始）
% - 绿色线：n=50时刻的输入产生的响应（从n=50开始）
% - 青色线：n=80时刻的输入产生的响应（从n=80开始）
% 
% 关键理解：
% - 每个输入冲激分量x(k)都会产生一个响应x(k)·h(n-k)
% - 这个响应从时刻k开始，持续M个时刻
% - 不同时刻的响应会重叠（例如n=25时刻，既有n=20的响应，也有n=21,22...的响应）
subplot(4,1,3);
plot(n, zeros(1,N), 'k-', 'LineWidth', 0.5);  % 基线（y=0）
hold on;
colors = {'m', 'g', 'c'};
for i = 1:length(k_list)
    plot(n, y_k_list{i}, colors{i}, 'LineWidth', 1.5);
    % 标记响应的起始时刻
    text(k_list(i), max(y_k_list{i})+0.15, ...
        ['τ=' num2str(k_list(i)) '的响应'], 'Color', colors{i}, 'FontSize', 10, 'FontWeight', 'bold');
    % 用竖线标记输入冲激的位置
    plot([k_list(i), k_list(i)], [0, max(y_k_list{i})], [colors{i} '--'], 'LineWidth', 1);
end
xlabel('时间n'); ylabel('幅度');
title('3. 卷积中间过程：输入关键冲激分量对应的延迟响应 x(τ)·h(n-τ)');
legend('基线', 'τ=20的响应', 'τ=50的响应', 'τ=80的响应', 'Location', 'best');
% 计算所有延迟响应的最大值（确保是标量）
max_y_k = -inf;
for i = 1:length(y_k_list)
    max_y_k = max(max_y_k, max(y_k_list{i}));
end
text(10, max_y_k-0.3, ...
    '理解：每个输入冲激x(τ)产生延迟响应x(τ)·h(n-τ)，从时刻τ开始', ...
    'FontSize', 9, 'Color', 'blue');
grid on;

% ============================================================================
% 子图4：卷积输出（滤波结果）
% ============================================================================
% 这个图展示最终结果：所有延迟响应的叠加
% - 蓝色实线：滤波后的输出y(n)
% - 红色虚线：原始低频信号（对比参考）
% - 可以看到：输出信号更平滑，噪声被滤除了
% 
% 关键理解：
% - y(n) = 所有时刻k的延迟响应x(k)·h(n-k)的叠加
% - 例如：y(25) = x(20)·h(5) + x(21)·h(4) + x(22)·h(3) + ... + x(25)·h(0) + ...
% - 这就是卷积公式：y(n) = Σ x(k)·h(n-k) = x(n) * h(n)
subplot(4,1,4);
plot(n, y, 'b', 'LineWidth', 1.5);
hold on;
plot(n, x_low, 'r--', 'LineWidth', 1.2);  % 叠加原始低频信号（对比）
xlabel('时间n'); ylabel('幅度');
title('4. 卷积输出y(n) = x(n) * h(n) = Σ x(k)·h(n-k)（滤波后信号）');
legend('滤波输出y(n)', '原始低频信号x_{low}(n)', 'Location', 'best');
text(50, max(y)-0.5, '输出y(n) = 所有延迟响应的叠加', 'Color', 'blue', 'FontSize', 10, 'FontWeight', 'bold');
text(50, max(y)-0.8, '例如：y(25) = x(20)·h(5) + x(21)·h(4) + x(22)·h(3) + ...', ...
    'Color', 'green', 'FontSize', 9);
grid on;

sgtitle('卷积物理意义：输入拆解为冲激分量 → 延迟响应 → 叠加形成输出', ...
    'FontSize', 12, 'FontWeight', 'bold');